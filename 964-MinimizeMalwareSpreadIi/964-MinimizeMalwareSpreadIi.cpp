// Last updated: 12/8/2025, 11:26:43 PM
class Solution {
private:
    vector<int> root;
    vector<int> rank;
    void init(int n) {
        root.resize(n);
        rank.resize(n);
        for (int i = 0; i < n; ++i) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    int find(int v) {
        return root[v] == v ? root[v] : root[v] = find(root[v]);
    }

    bool join(int v, int u) {
        v = find(v);
        u = find(u);
        if (v == u) 
            return false;
        root[u] = v;
        rank[v] += rank[u];
        return true;
    }


public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> clean(n, 1);
        for (int m : initial) clean[m] = 0;
        init(n);

        // first, only process clean components
        for (int i = 0; i < n; ++i) if (clean[i] == 1)
            for (int j = 0; j < n; ++j) if (clean[j] == 1)
                if (graph[i][j] == 1)
                    join(i, j);

        
        // second, connect clean components to infected nodes
        // and counts each clean components connect to how many infected nodes;
        vector<int> count(n, 0);
        unordered_map<int, unordered_set<int>> components;
        for (int m : initial) {
            for (int j = 0; j < n; ++j) if (clean[j] == 1)
                if (graph[m][j] == 1) {
                    components[m].insert(find(j));
                }
            for (int c : components[m])
                count[c]++;
        }
        
        int ans = -1, sz = -1;
        for (int m : initial) {
            int score = 0;
            for (int c : components[m])
                if (count[c] == 1)
                    score += rank[find(c)];
            
            if (score > sz || score == sz && m < ans) {
                ans = m;
                sz = score;
            }
        }
        return ans;
    
    }
};